         _run_channel_spin_thread(state)
            else:
                state.managed_calls += 1
            return call

    return create


class _ChannelConnectivityState(object):
    lock: threading.RLock
    channel: grpc.Channel
    polling: bool
    connectivity: grpc.ChannelConnectivity
    try_to_connect: bool
    # TODO(xuanwn): Refactor this: https://github.com/grpc/grpc/issues/31704
    callbacks_and_connectivities: List[
        Sequence[
            Union[
                Callable[[grpc.ChannelConnectivity], None],
                Optional[grpc.ChannelConnectivity],
            ]
        ]
    ]
    delivering: bool

    def __init__(self, channel: grpc.Channel):
        self.lock = threading.RLock()
        self.channel = channel
        self.polling = False
        self.connectivity = None
        self.try_to_connect = False
        self.callbacks_and_connectivities = []
        self.delivering = False

    def reset_postfork_child(self) -> None:
        self.polling = False
        self.connectivity = None
        self.try_to_connect = False
        self.callbacks_and_connectivities = []
        self.delivering = False


def _deliveries(
    state: _ChannelConnectivityState,
) -> List[Callable[[grpc.ChannelConnectivity], None]]:
    callbacks_needing_update = []
    for callback_and_connectivity in state.callbacks_and_connectivities:
        (
            callback,
            callback_connectivity,
        ) = callback_and_connectivity
        if callback_connectivity is not state.connectivity:
            callbacks_needing_update.append(callback)
            callback_and_connectivity[1] = state.connectivity
    return callbacks_needing_update


def _deliver(
    state: _ChannelConnectivityState,
    initial_connectivity: grpc.ChannelConnectivity,
    initial_callbacks: Sequence[Callable[[grpc.ChannelConnectivity], None]],
) -> None:
    connectivity = initial_connectivity
    callbacks = initial_callbacks
    while True:
        for callback in callbacks:
            cygrpc.block_if_fork_in_progress(state)
            try:
                callback(connectivity)
            except Exception:  # pylint: disable=broad-except
                _LOGGER.exception(
                    _CHANNEL_SUBSCRIPTION_CALLBACK_ERROR_LOG_MESSAGE
                )
        with state.lock:
            callbacks = _deliveries(state)
            if callbacks:
                connectivity = state.connectivity
            else:
                state.delivering = False
                return


def _spawn_delivery(
    state: _ChannelConnectivityState,
    callbacks: Sequence[Callable[[grpc.ChannelConnectivity], None]],
) -> None:
    delivering_thread = cygrpc.ForkManagedThread(
        target=_deliver,
        args=(
            state,
            state.connectivity,
            callbacks,
        ),
    )
    delivering_thread.setDaemon(True)
    delivering_thread.start()
    state.delivering = True


# NOTE(https://github.com/grpc/grpc/issues/3064): We'd rather not poll.
def _poll_connectivity(
    state: _ChannelConnectivityState,
    channel: grpc.Channel,
    initial_try_to_connect: bool,
) -> None:
    try_to_connect = initial_try_to_connect
    connectivity = channel.check_connectivity_state(try_to_connect)
    with state.lock:
        state.connectivity = (
            _common.CYGRPC_CONNECTIVITY_STATE_TO_CHANNEL_CONNECTIVITY[
                connectivity
            ]
        )
        callbacks = tuple(
            callback for callback, _ in state.callbacks_and_connectivities
        )
        for callback_and_connectivity in state.callbacks_and_connectivities:
            callback_and_connectivity[1] = state.connectivity
        if callbacks:
            _spawn_delivery(state, callbacks)
    while True:
        event = channel.watch_connectivity_state(
            connectivity, time.time() + 0.2
        )
        cygrpc.block_if_fork_in_progress(state)
        with state.lock:
            if (
                not state.callbacks_and_connectivities
                and not state.try_to_connect
            ):
                state.polling = False
                state.connectivity = None
                break
            try_to_connect = state.try_to_connect
            state.try_to_connect = False
        if event.success or try_to_connect:
            connectivity = channel.check_connectivity_state(try_to_connect)
            with state.lock:
                state.connectivity = (
                    _common.CYGRPC_CONNECTIVITY_STATE_TO_CHANNEL_CONNECTIVITY[
                        connectivity
                    ]
                )
                if not state.delivering:
                    callbacks = _deliveries(state)
                    if callbacks:
                        _spawn_delivery(state, callbacks)


def _subscribe(
    state: _ChannelConnectivityState,
    callback: Callable[[grpc.ChannelConnectivity], None],
    try_to_connect: bool,
) -> None:
    with state.lock:
        if not state.callbacks_and_connectivities and not state.polling:
            polling_thread = cygrpc.ForkManagedThread(
                target=_poll_connectivity,
                args=(state, state.channel, bool(try_to_connect)),
            )
            polling_thread.setDaemon(True)
            polling_thread.start()
            state.polling = True
            state.callbacks_and_connectivities.append([callback, None])
        elif not state.delivering and state.connectivity is not None:
            _spawn_delivery(state, (callback,))
            state.try_to_connect |= bool(try_to_connect)
            state.callbacks_and_connectivities.append(
                [callback, state.connectivity]
            )
        else:
            state.try_to_connect |= bool(try_to_connect)
            state.callbacks_and_connectivities.append([callback, None])


def _unsubscribe(
    state: _ChannelConnectivityState,
    callback: Callable[[grpc.ChannelConnectivity], None],
) -> None:
    with state.lock:
        for index, (subscribed_callback, unused_connectivity) in enumerate(
            state.callbacks_and_connectivities
        ):
            if callback == subscribed_callback:
                state.callbacks_and_connectivities.pop(index)
                break


def _augment_options(
    base_options: Sequence[ChannelArgumentType],
    compression: Optional[grpc.Compression],
) -> Sequence[ChannelArgumentType]:
    compression_option = _compression.create_channel_option(compression)
    return (
        tuple(base_options)
        + compression_option
        + (
            (
                cygrpc.ChannelArgKey.primary_user_agent_string,
                _USER_AGENT,
            ),
        )
    )


def _separate_channel_options(
    options: Sequence[ChannelArgumentType],
) -> Tuple[Sequence[ChannelArgumentType], Sequence[ChannelArgumentType]]:
    """Separates core channel options from Python channel options."""
    core_options = []
    python_options = []
    for pair in options:
        if (
            pair[0]
            == grpc.experimental.ChannelOptions.SingleThreadedUnaryStream
        ):
            python_options.append(pair)
        else:
            core_options.append(pair)
    return python_options, core_options


class Channel(grpc.Channel):
    """A cygrpc.Channel-backed implementation of grpc.Channel."""

    _single_threaded_unary_stream: bool
    _channel: cygrpc.Channel
    _call_state: _ChannelCallState
    _connectivity_state: _ChannelConnectivityState
    _target: str
    _registered_call_handles: Dict[str, int]

    def __init__(
        self,
        target: str,
        options: Sequence[ChannelArgumentType],
        credentials: Optional[grpc.ChannelCredentials],
        compression: Optional[grpc.Compression],
    ):
        """Constructor.

        Args:
          target: The target to which to connect.
          options: Configuration options for the channel.
          credentials: A cygrpc.ChannelCredentials or None.
          compression: An optional value indicating the compression method to be
            used over the lifetime of the channel.
        """
        python_options, core_options = _separate_channel_options(options)
        self._single_threaded_unary_stream = (
            _DEFAULT_SINGLE_THREADED_UNARY_STREAM
        )
        self._process_python_options(python_options)
        self._channel = cygrpc.Channel(
            _common.encode(target),
            _augment_options(core_options, compression),
            credentials,
        )
        self._target = target
        self._call_state = _ChannelCallState(self._channel)
        self._connectivity_state = _ChannelConnectivityState(self._channel)
        cygrpc.fork_register_channel(self)
        if cygrpc.g_gevent_activated:
            cygrpc.gevent_increment_channel_count()

    def _get_registered_call_handle(self, method: str) -> int:
        """
        Get the registered call handle for a method.

        This is a semi-private method. It is intended for use only by gRPC generated code.

        This method is not thread-safe.

        Args:
          method: Required, the method name for the RPC.

        Returns:
          The registered call handle pointer in the form of a Python Long.
        """
        return self._channel.get_registered_call_handle(_common.encode(method))

    def _process_python_options(
        self, python_options: Sequence[ChannelArgumentType]
    ) -> None:
        """Sets channel attributes according to python-only channel options."""
        for pair in python_options:
            if (
                pair[0]
                == grpc.experimental.ChannelOptions.SingleThreadedUnaryStream
            ):
                self._single_threaded_unary_stream = True

    def subscribe(
        self,
        callback: Callable[[grpc.ChannelConnectivity], None],
        try_to_connect: Optional[bool] = None,
    ) -> None:
        _subscribe(self._connectivity_state, callback, try_to_connect)

    def unsubscribe(
        self, callback: Callable[[grpc.ChannelConnectivity], None]
    ) -> None:
        _unsubscribe(self._connectivity_state, callback)

    # pylint: disable=arguments-differ
    def unary_unary(
        self,
        method: str,
        request_serializer: Optional[SerializingFunction] = None,
        response_deserializer: Optional[DeserializingFunction] = None,
        _registered_method: Optional[bool] = False,
    ) -> grpc.UnaryUnaryMultiCallable:
        _registered_call_handle = None
        if _registered_method:
            _registered_call_handle = self._get_registered_call_handle(method)
        return _UnaryUnaryMultiCallable(
            self._channel,
            _channel_managed_call_management(self._call_state),
            _common.encode(method),
            _common.encode(self._target),
            request_serializer,
            response_deserializer,
            _registered_call_handle,
        )

    # pylint: disable=arguments-differ
    def unary_stream(
        self,
        method: str,
        request_serializer: Optional[SerializingFunction] = None,
        response_deserializer: Optional[DeserializingFunction] = None,
        _registered_method: Optional[bool] = False,
    ) -> grpc.UnaryStreamMultiCallable:
        _registered_call_handle = None
        if _registered_method:
            _registered_call_handle = self._get_registered_call_handle(method)
        # NOTE(rbellevi): Benchmarks have shown that running a unary-stream RPC
        # on a single Python thread results in an appreciable speed-up. However,
        # due to slight differences in capability, the multi-threaded variant
        # remains the default.
        if self._single_threaded_unary_stream:
            return _SingleThreadedUnaryStreamMultiCallable(
                self._channel,
                _common.encode(method),
                _common.encode(self._target),
                request_serializer,
                response_deserializer,
                _registered_call_handle,
            )
        else:
            return _UnaryStreamMultiCallable(
                self._channel,
                _channel_managed_call_management(self._call_state),
                _common.encode(method),
                _common.encode(self._target),
                request_serializer,
                response_deserializer,
                _registered_call_handle,
            )

    # pylint: disable=arguments-differ
    def stream_unary(
        self,
        method: str,
        request_serializer: Optional[SerializingFunction] = None,
        response_deserializer: Optional[DeserializingFunction] = None,
        _registered_method: Optional[bool] = False,
    ) -> grpc.StreamUnaryMultiCallable:
        _registered_call_handle = None
        if _registered_method:
            _registered_call_handle = self._get_registered_call_handle(method)
        return _StreamUnaryMultiCallable(
            self._channel,
            _channel_managed_call_management(self._call_state),
            _common.encode(method),
            _common.encode(self._target),
            request_serializer,
            response_deserializer,
            _registered_call_handle,
        )

    # pylint: disable=arguments-differ
    def stream_stream(
        self,
        method: str,
        request_serializer: Optional[SerializingFunction] = None,
        response_deserializer: Optional[DeserializingFunction] = None,
        _registered_method: Optional[bool] = False,
    ) -> grpc.StreamStreamMultiCallable:
        _registered_call_handle = None
        if _registered_method:
            _registered_call_handle = self._get_registered_call_handle(method)
        return _StreamStreamMultiCallable(
            self._channel,
            _channel_managed_call_management(self._call_state),
            _common.encode(method),
            _common.encode(self._target),
            request_serializer,
            response_deserializer,
            _registered_call_handle,
        )

    def _unsubscribe_all(self) -> None:
        state = self._connectivity_state
        if state:
            with state.lock:
                del state.callbacks_and_connectivities[:]

    def _close(self) -> None:
        self._unsubscribe_all()
        self._channel.close(cygrpc.StatusCode.cancelled, "Channel closed!")
        cygrpc.fork_unregister_channel(self)
        if cygrpc.g_gevent_activated:
            cygrpc.gevent_decrement_channel_count()

    def _close_on_fork(self) -> None:
        self._unsubscribe_all()
        self._channel.close_on_fork(
            cygrpc.StatusCode.cancelled, "Channel closed due to fork"
        )

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self._close()
        return False

    def close(self) -> None:
        self._close()

    def __del__(self):
        # TODO(https://github.com/grpc/grpc/issues/12531): Several releases
        # after 1.12 (1.16 or thereabouts?) add a "self._channel.close" call
        # here (or more likely, call self._close() here). We don't do this today
        # because many valid use cases today allow the channel to be deleted
        # immediately after stubs are created. After a sufficient period of time
        # has passed for all users to be trusted to freeze out to their channels
        # for as long as they are in use and to close them after using them,
        # then deletion of this grpc._channel.Channel instance can be made to
        # effect closure of the underlying cygrpc.Channel instance.
        try:
            self._unsubscribe_all()
        except:  # pylint: disable=bare-except
            # Exceptions in __del__ are ignored by Python anyway, but they can
            # keep spamming logs.  Just silence them.
            pass
     ğG   ğˆG   ğˆG   @‰G   @‰G   0G   0G   pG   pG   €JG   €JG   ğG   ğG   0G   0G   pG   pG   °G   °G   pG   pG   °G   °G   ğG   ğG   pG   pG   °G   °G   ğG   ğG   Ø   Ø   ğ;D   ğ;D   ğD   ğD   0D   0D   ğĞ³   ğĞ³   0·   0·   ğ@œ   ğ@œ   0¹   0¹   0!    0!    °ê   °ê   `<	   `<	   `6	   `6	   pĞ   pĞ   07   07   ğ   ğ   ğ   ğ   0¦¹   0¦¹   0±¹   0±¹   p9ø   p9ø   pE   pE   ğE   ğE   p2E   p2E   °>E   °>E   0F   0F   pF   pF   °&F   °&F   ğ(F   ğ(F   pE   pE   ğ:E   ğ:E   02E   02E   0ŠG   0ŠG   ;H   ;H   ğF   ğF   p"F   p"F   `ó   `ó   0F   0F   pD¬   pD¬   0G   0G   0G   0G   pG   pG   põD   põD   °G   °G    œG    œG   0G   0G   ğ/G   ğ/G   p0G   p0G   00G   00G   ĞE   ĞE   ğ0G   ğ0G   `åE   `åE   €G   €G   ĞŞE   ĞŞE   P¨E   P¨E   °dD   °dD   °1G   °1G   ©E   ©E   02G   02G   p2G   p2G   ¶E   ¶E   p3G   p3G   @æE   @æE    G    G   °eD   °eD   °·E   °·E   05G   05G   p5G   p5G   °5G   °5G   ğ5G   ğ5G   °7G   °7G   ğ7G   ğ7G   09G   09G   p9G   p9G    èE    èE   àèE   àèE   ğ×H   ğ×H   pF   pF   0I   0I   0
I   0
I   ş   ş   ğµG   ğµG   ¶G   ¶G   0·G   0·G   Ğ·G   Ğ·G    ¸G    ¸G   0I   0I   ğ^G   ğ^G   ƒI   ƒI   0I   0I   À¸G   À¸G   pWG   pWG   ¹G   ¹G   °I   °I   ğƒI   ğƒI   °¹G   °¹G    ºG    ºG   pI   pI   PºG   PºG   ğºG   ğºG   @»G   @»G   0I   0I   à»G   à»G   0¼G   0¼G   €¼G   €¼G   Ğ¼G   Ğ¼G   p½G   p½G   À½G   À½G   ¾G   ¾G   `¾G   `¾G   °¾G   °¾G    ¿G    ¿G   P¿G   P¿G    ¿G    ¿G   0€J   0€J   Ğ€J   Ğ€J    J    J   pJ   pJ   ÀJ   ÀJ   ‚J   ‚J    ƒJ    ƒJ   PƒJ   PƒJ   0I   0I   pI   pI   °ùH   °ùH   ğmG   ğmG   à@J   à@J   °I   °I   pI   pI   `‡J   `‡J   pI   pI   ğI   ğI   0I   0I   °I   °I   ğI   ğI   PŠI   PŠI   ğI   ğI    rG    rG   0ŠJ   0ŠJ   ‹I   ‹I    tG    tG   pI   pI   p‹J   p‹J   À‹J   À‹J   ğ I   ğ I   0!I   0!I   `ŒJ   `ŒJ   vG   vG   ÀvG   ÀvG   °!I   °!I   ğ!I   ğ!I   p"I   p"I   °"I   °"I   0ŒI   0ŒI   ğJ   ğJ   ğ#I   ğ#I   J   J   °I   °I   p%I   p%I   àJ   àJ   0&I   0&I   €J   €J   pJ   pJ   ÀJ   ÀJ   p'I   p'I   ğ(I   ğ(I   p)I   p)I   @BJ   @BJ    nÄ    nÄ                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   °MF   °MF   0óL   0óL   °şM   °şM   €ôL   €ôL   °ôL   °ôL   ğ‘M   ğ‘M   0’M   0’M   p’M   p’M   ğöL   ğöL   ğ™M   ğ™M   P÷L   P÷L   øL   øL    øL    øL   `ùL   `ùL   pM   pM   @ûL   @ûL   °ŸM   °ŸM   PıL   PıL   pşL   pşL   PˆN   PˆN   °¡M   °¡M   ğ¡M   ğ¡M   ğ¢M   ğ¢M   p£M   p£M   ğ£M   ğ£M   0¤M   0¤M   °¤M   °¤M   p¥M   p¥M   0#K   0#K   °¥M   °¥M   O   O   ğ¥M   ğ¥M   0N   0N   °©M   °©M    O    O   ğ©M   ğ©M   PSF   PSF   `‘N   `‘N   ğªM   ğªM   àSF   àSF   p­M   p­M   °­M   °­M   ğ­M   ğ­M   0®M   0®M   p®M   p®M   °®M   °®M   ğ®M   ğ®M   °×O   °×O   °KN   °KN   0/Â   0/Â    fJ    fJ   °=Â   °=Â   €Á   €Á   0%Â   0%Â   °3Q   °3Q   p3Q   p3Q   03Q   03Q   ğ2Q   ğ2Q   °2Q   °2Q   p2Q   p2Q   02Q   02Q   ğO   ğO   ğ1Q   ğ1Q   °ÇI   °ÇI   0<   0<   p1Q   p1Q   »N   »N   à»N   à»N   0¼N   0¼N   0-N   0-N   -N   -N    ½N    ½N   ğ-N   ğ-N   ¾N   ¾N   °0Q   °0Q    Á    Á   °O   °O   °%Â   °%Â   0ÌI   0ÌI    ÁQ    ÁQ   °*Q   °*Q   pÁQ   pÁQ   ÀÁQ   ÀÁQ   0N   0N   P1N   P1N   °1N   °1N    ÃQ    ÃQ   p2N   p2N   Ğ2N   Ğ2N   ÄQ   ÄQ   0ÅQ   0ÅQ   ĞÅQ   ĞÅQ    ÆQ    ÆQ   03N   03N   3N   3N   P4N   P4N   ÀÆQ   ÀÆQ   p5N   p5N   06N   06N   P¿N   P¿N   p%Â   p%Â   pQ   pQ   0Q   0Q   À9O   À9O   €‡Q   €‡Q   Ğ8N   Ğ8N   ğQ   ğQ   p8N   p8N   09N   09N   9N   9N   ğ9N   ğ9N   P:N   P:N   °:N   °:N   PP   PP   ;N   ;N   @ÉQ   @ÉQ   ğ*Q   ğ*Q   pQ   pQ    ÁP    ÁP   °ÁP   °ÁP   °ÍI   °ÍI   €ÏQ   €ÏQ   <N   <N   0Q   0Q   ĞÏQ   ĞÏQ    ĞQ    ĞQ   °=N   °=N   >N   >N   p>N   p>N   `ÑQ   `ÑQ   0?N   0?N   ?N   ?N    ÒQ    ÒQ   pQ   pQ   àÇP   àÇP   ÈP   ÈP   @R   @R   @P   @P   ğQ   ğQ   °Q   °Q   pQ   pQ   PAR   PAR   °AR   °AR   BR   BR   pBR   pBR   0CR   0CR   CR   CR    P    P   PDR   PDR   0Q   0Q   ĞÔQ   ĞÔQ   ğQ   ğQ   0ÌP   0ÌP   °Q   °Q   ÌP   ÌP   pQ   pQ    ÕQ    ÕQ   0Q   0Q   pÕQ   pÕQ   PP   PP   ğQ   ğQ   ÖQ   ÖQ   `ÖQ   `ÖQ   ER   ER   pER   pER   ĞER   ĞER   0FR   0FR   FR   FR   ğFR   ğFR   @ØQ   @ØQ   °ĞP   °ĞP   `ÌQ   `ÌQ    ÓP    ÓP   p^P   p^P   ğÏI   ğÏI    ÜQ    ÜQ   @İQ   @İQ   İQ   İQ   àİQ   àİQ   KR   KR   ĞKR   ĞKR    ßQ    ßQ   0LR   0LR   àQ   àQ   0ZP   0ZP   `ÛQ   `ÛQ   ğQ   ğQ   ğSP   ğSP   0ÒI   0ÒI   ğáQ   ğáQ   pNR   pNR   pSP   pSP   àâQ   àâQ   0ãQ   0ãQ   OR   OR   ğOR   ğOR   °PR   °PR   päQ   päQ   QR   QR   pQR   pQR   PáQ   PáQ   0IP   0IP   pIP   pIP   °ÓI   °ÓI   0èQ   0èQ   °SR   °SR   TR   TR   0HP   0HP   ğGP   ğGP   €èQ   €èQ   ĞèQ   ĞèQ    éQ    éQ   péQ   péQ   `êQ   `êQ   °êQ   °êQ   ĞTR   ĞTR    ëQ    ëQ   ğFP   ğFP   ğ3Q   ğ3Q   0TP   0TP   0ØI   0ØI   0íQ   0íQ   ÀîQ   ÀîQ   ïQ   ïQ   `ïQ   `ïQ   PVR   PVR   WR   WR    ğQ    ğQ   pWR   pWR   ĞWR   ĞWR   °_P   °_P   ìQ   ìQ   °ºM   °ºM   ğnJ   ğnJ   `ôQ   `ôQ   pºM   pºM   ğºM   ğºM   0»M   0»M   íP   íP   °»M   °»M   ÀíP   ÀíP   @P   @P   0¼M   0¼M   p¼M   p¼M   °¼M   °¼M   ğíP   ğíP   0¾M   0¾M    îP    îP   PõQ   PõQ   @öQ   @öQ   ğ¾M   ğ¾M   0¿M   0¿M   °¿M   °¿M   pïP   pïP   °†M   °†M   0÷Q   0÷Q   €÷Q   €÷Q   ğ±M   ğ±M   °€M   °€M   0†M   0†M   ğ¸M   ğ¸M   °¸M   °¸M   ğ·M   ğ·M   0ŠM   0ŠM   °ĞO   °ĞO   ğĞO   ğĞO   0ÑO   0ÑO   0ËO   0ËO    øQ    øQ   ÀğP   ÀğP   pÊO   pÊO   0ÊO   0ÊO   °ãO   °ãO   ğãO   ğãO   0äO   0äO   pøQ   pøQ   °äO   °äO   0ßO   0ßO   ğŞO   ğŞO   °ßO   °ßO   °ŞO   °ŞO   pŞO   pŞO   póO   póO   0ïO   0ïO   ÀøQ   ÀøQ   ğîO   ğîO   °îO   °îO   ùQ   ùQ   °ùQ   °ùQ   0ÌO   0ÌO   ğËO   ğËO   0ÀO   0ÀO   pÀO   pÀO   °ÀO   °ÀO   p]R   p]R   ğÀO   ğÀO    úQ    úQ   PúQ   PúQ    úQ    úQ   @ûQ   @ûQ   ûQ   ûQ   àûQ   àûQ   0üQ   0üQ   °ÃO   °ÃO   à÷P   à÷P   PôP   PôP   ğÄO   ğÄO   ğÁO   ğÁO   °ÄO   °ÄO   ğÆO   ğÆO   0ÇO   0ÇO   pÇO   pÇO   ğÈO   ğÈO   °ÈO   °ÈO   °ÇO   °ÇO   ğÇO   ğÇO   0ÈO   0ÈO   pÈO   pÈO   0ÉO   0ÉO   pÉO   pÉO   °ÉO   °ÉO   ğÉO   ğÉO   ÀıQ   ÀıQ   0ÀS   0ÀS   €úP   €úP   ğS   ğS   ûP   ûP   pûP   pûP   °ÀS   °ÀS   ĞûP   ĞûP   0ÁS   0ÁS   üP   üP   pÁS   pÁS   °ÁS   °ÁS   pÂS   pÂS   °ÂS   °ÂS   ğÂS   ğÂS   °ÃS   °ÃS   ğÅS   ğÅS   pÆS   pÆS   ğÆS   ğÆS   °ÇS   °ÇS   ğÇS   ğÇS   °ÈS   °ÈS   0ÉS   0ÉS   0ÊS   0ÊS   0ËS   0ËS   ğËS   ğËS   0ÌS   0ÌS   pÌS   pÌS   °ÌS   °ÌS   ğÌS   ğÌS   0ÍS   0ÍS    T    T   ğÍS   ğÍS   pÎS   pÎS   ğÎS   ğÎS   0ÏS   0ÏS    ƒT    ƒT   °ÏS   °ÏS   ğÏS   ğÏS   pĞS   pĞS   °ĞS   °ĞS   0ÑS   0ÑS   °ÑS   °ÑS   pÒS   pÒS   ğÒS   ğÒS   Ğ…T   Ğ…T   °ÓS   °ÓS   ğÓS   ğÓS   pÔS   pÔS   0ÕS   0ÕS   pKT   pKT   pÖS   pÖS   p×S   p×S   °×S   °×S   ğ×S   ğ×S   à‡T   à‡T   ˆT   ˆT   0ØS   0ØS   pØS   pØS   ğØS   ğØS   pÙS   pÙS   ğÙS   ğÙS   pÚS   pÚS   0ÛS   0ÛS   0ÜS   0ÜS   pÜS   pÜS   0İS   0İS   °İS   °İS   ğİS   ğİS   0ŞS   0ŞS   pŞS   pŞS   €OT   €OT    RT    RT   ğRT   ğRT   €TT   €TT   VT   VT   àT   àT   ‘T   ‘T   @‘T   @‘T   0áS   0áS   páS   páS   °áS   °áS   ğáS   ğáS   0âS   0âS   pâS   pâS   °ãS   °ãS   À’T   À’T   0åS   0åS   °åS   °åS   0æS   0æS   pæS   pæS   °æS   °æS   ğæS   ğæS   ğ’T   ğ’T   pçS   pçS   ğçS   ğçS   °èS   °èS   péS   péS   °êS   °êS    –T    –T   ğêS   ğêS   °–T   °–T   pëS   pëS   pìS   pìS   °ìS   °ìS   ğìS   ğìS   @—T   @—T   0íS   0íS   °íS   °íS   ğíS   ğíS   0îS   0îS   pîS   pîS   °îS   °îS   °[T   °[T   ğîS   ğîS   0ïS   0ïS   pïS   pïS   °ïS   °ïS    \T    \T   @]T   @]T   Ğ—T   Ğ—T    ˜T    ˜T   pñS   pñS   °ñS   °ñS   0˜T   0˜T   ]T   ]T   ˜T   ˜T   à]T   à]T   0^T   0^T   póS   póS   Ğ^T   Ğ^T   °™T   °™T   à™T   à™T   °óS   °óS   ğóS   ğóS   0ôS   0ôS   ğôS   ğôS   0õS   0õS   À_T   À_T   `T   `T   p÷S   p÷S   °÷S   °÷S   ğ÷S   ğ÷S   `›T   `›T   0øS   0øS   pøS   pøS   À›T   À›T   °øS   °øS   0ùS   0ùS   pùS   pùS   °ùS   °ùS   ğùS   ğùS   0úS   0úS   púS   púS   °úS   °úS   ğúS   ğúS   pûS   pûS   ğûS   ğûS   0üS   0üS   °üS   °üS   0ıS   0ıS   °ıS   °ıS    aT    aT   0ÿS   0ÿS   pÿS   pÿS   °ÿS   °ÿS   0@U   0@U   p@U   p@U   °@U   °@U   ğ@U   ğ@U   0AU   0AU    T    T   pAU   pAU   ğAU   ğAU   ğaT   ğaT   àbT   àbT   €cT   €cT   pCU   pCU   °CU   °CU   ğCU   ğCU   ğDU   ğDU   0EU   0EU    dT    dT   ğEU   ğEU   pFU   pFU   °FU   °FU   0GU   0GU   °GU   °GU   Ğ T   Ğ T   pHU   pHU   `¡T   `¡T   ğHU   ğHU    ¢T    ¢T   pIU   pIU   °¢T   °¢T   ğIU   ğIU   pJU   pJU   @£T   @£T   °JU   °JU   pKU   pKU   °KU   °KU   0¤T   0¤T   0LU   0LU   ğLU   ğLU   0MU   0MU   pMU   pMU   °MU   °MU   ğMU   ğMU   À¤T   À¤T   0NU   0NU   °NU   °NU    ¥T    ¥T   °OU   °OU   0PU   0PU   `jT   `jT   pQU   pQU   °QU   °QU   ğQU   ğQU   pRU   pRU   ğRU   ğRU   pSU   pSU   Ğ¦T   Ğ¦T   °SU   °SU   §T   §T   0TU   0TU    ¨T    ¨T   ğTU   ğTU   0UU   0UU   °UU   °UU   °VU   °VU   0WU   0WU   pWU   pWU   °WU   °WU   pXU   pXU   °XU   °XU   Ğ©T   Ğ©T    ªT    ªT   ğXU   ğXU   0YU   0YU   0ZU   0ZU   pZU   pZU   °ZU   °ZU   °«T   °«T   à«T   à«T   p[U   p[U   °[U   °[U   0\U   0\U   p\U   p\U   ğ\U   ğ\U   `oT   `oT   p]U   p]U   ğ]U   ğ]U   °oT   °oT   °^U   °^U   ğ^U   ğ^U   0_U   0_U   p_U   p_U   °_U   °_U   °`U   °`U   ğ`U   ğ`U   0aU   0aU   PpT   PpT   paU   paU   0rT   0rT   ĞrT   ĞrT   °bU   °bU   ğbU   ğbU   0cU   0cU   °cU   °cU   Ğ¯T   Ğ¯T   ğcU   ğcU   0dU   0dU   pdU   pdU   °dU   °dU   peU   peU   0fU   0fU   °fU   °fU   ğfU   ğfU   0gU   0gU   °gU   °gU   ğgU   ğgU   phU   phU   0iU   0iU   °iU   °iU   ²T   ²T   ğjU   ğjU   0kU   0kU   pkU   pkU   plU   plU   0mU   0mU    zT    zT   0nU   0nU   0oU   0oU   poU   poU   ğoU   ğoU    ¸T    ¸T   0wU   0wU   pwU   pwU   °wU   °wU   ğwU   ğwU   pxU   pxU   ğaF   ğaF   0×S   0×S   °ËS   °ËS   0zU   0zU   ğyU   ğyU    şP    şP   pzU   pzU   °zU   °zU   °ıP   °ıP   ğzU   ğzU   0{U   0{U   p{U   p{U   €ıP   €ıP   °{U   °{U   ğ{U   ğ{U   0|U   0|U   p|U   p|U   pşP   pşP   °|U   °|U   ğ|U   ğ|U   0}U   0}U   p}U   p}U   °}U   °}U   ğ}U   ğ}U   @şP   @şP   0~U   0~U   p~U   p~U   °~U   °~U   ğ~U   ğ~U   0U   0U   pU   pU   °U   °U   0 V   0 V   p V   p V   ° V   ° V   ğ V   ğ V   0V   0V   pV   pV   °V   °V   ğV   ğV   0V   0V   pV   pV   şP   şP   ĞşP   ĞşP   °V   °V    ÿP    ÿP   ğV   ğV   0ÿP   0ÿP   0V   0V   0dF   0dF   pV   pV   °V   °V   0V   0V   pV   pV   °V   °V   ğV   ğV   0V   0V   pV   pV   °V   °V   ğV   ğV   0V   0V   °hF   °hF   °V   °V   ğV   ğV   °V   °V   0V   0V   pV   pV   °V   °V   ğV   ğV   °V   °V   ğV   ğV   0V   0V   @rF   @rF   °V   °V   pV   pV   ğV   ğV   pV   pV   °V   °V   ğÀV   ğÀV   0V   0V    ˆU    ˆU   ğˆU   ğˆU   ğV   ğV   0V   0V   ‰U   ‰U   à‰U   à‰U   ğV   ğV   °V   °V   ğV   ğV   0 V   0 V   p V   p V   ğ V   ğ V   0!V   0!V   p!V   p!V   °!V   °!V   ğ!V   ğ!V   0"V   0"V   °"V   °"V   p#V   p#V   ĞŠU   ĞŠU   °$V   °$V   ğ$V   ğ$V    ‹U    ‹U   p%V   p%V   p&V   p&V   p'V   p'V   °(V   °(V   °)V   °)V   ğ)V   ğ)V   0*V   0*V   °*V   °*V   0+V   0+V   0,V   0,V   ğ,V   ğ,V   0-V   0-V   p-V   p-V   °-V   °-V   ğ-V   ğ-V    U    U   p.V   p.V   °.V   °.V   ğ.V   ğ.V   0/V   0/V   ğ/V   ğ/V    U    U   °0V   °0V   ğU   ğU   p1V   p1V   U   U   ğ1V   ğ1V   p2V   p2V   0U   0U   ğ2V   ğ2V   03V   03V   p3V   p3V   °3V   °3V   ğ3V   ğ3V   €U   €U   pU   pU   ‘U   ‘U   `‘U   `‘U   °‘U   °‘U   06V   06V   p6V   p6V   àĞV   àĞV   ÑV   ÑV   @ÑV   @ÑV   °;V   °;V   ğ;V   ğ;V   pÑV   pÑV   0<V   0<V   °<V   °<V   p=V   p=V   €™U   €™U   ğ=V   ğ=V   ÀšU   ÀšU   °>V   °>V   p?V   p?V   °ÀW   °ÀW   ğÀW   ğÀW   ğÁW   ğÁW   °›U   °›U   0ÂW   0ÂW   pÂW   pÂW    œU    œU   °ÂW   °ÂW   ğÂW   ğÂW    œU    œU   pÃW   pÃW   U   U   ğÃW   ğÃW   pÄW   pÄW   ğÄW   ğÄW   pÅW   pÅW   ğÅW   ğÅW   pÆW   pÆW   ğÆW   ğÆW   °ÇW   °ÇW   pÈW   pÈW   °ÈW   °ÈW   0ËW   0ËW   ° U   ° U    ¡U    ¡U   @¢U   @¢U   °ËW   °ËW   °ÌW   °ÌW   °ÖV   °ÖV   ğÌW   ğÌW   0ÍW   0ÍW   à¢U   à¢U   0£U   0£U   pÍW   pÍW   €£U   €£U   °ÍW   °ÍW   ğÍW   ğÍW   0ÎW   0ÎW   pÎW   pÎW   °ÎW   °ÎW   ğÎW   ğÎW   0ÏW   0ÏW   °ÏW   °ÏW   0ĞW   0ĞW   pĞW   pĞW   ğĞW   ğĞW   0ÑW   0ÑW   pÑW   pÑW   °ÑW   °ÑW   ÀÛV   ÀÛV   # Copyright 2016 gRPC authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""Invocation-side implementation of gRPC Python."""

import copy
import functools
import logging
import os
import sys
import threading
import time
import types
from typing import (
    Any,
    Callable,
    Dict,
    Iterator,
    List,
    Optional,
    Sequence,
    Set,
    Tuple,
    Union,
)

import grpc  # pytype: disable=pyi-error
from grpc import _common  # pytype: disable=pyi-error
from grpc import _compression  # pytype: disable=pyi-error
from grpc import _grpcio_metadata  # pytype: disable=pyi-error
from grpc import _observability  # pytype: disable=pyi-error
from grpc._cython import cygrpc
from grpc._typing import ChannelArgumentType
from grpc._typing import DeserializingFunction
from grpc._typing import IntegratedCallFactory
from grpc._typing import MetadataType
from grpc._typing import NullaryCallbackType
from grpc._typing import ResponseType
from grpc._typing import SerializingFunction
from grpc._typing import UserTag
import grpc.experimental  # pytype: disable=pyi-error

_LOGGER = logging.getLogger(__name__)

_USER_AGENT = "grpc-python/{}".format(_grpcio_metadata.__version__)

_EMPTY_FLAGS = 0

# NOTE(rbellevi): No guarantees are given about the maintenance of this
# environment variable.
_DEFAULT_SINGLE_THREADED_UNARY_STREAM = (
    os.getenv("GRPC_SINGLE_THREADED_UNARY_STREAM") is not None
)

_UNARY_UNARY_INITIAL_DUE = (
    cygrpc.OperationType.send_initial_metadata,
    cygrpc.OperationType.send_message,
    cygrpc.OperationType.send_close_from_client,
    cygrpc.OperationType.receive_initial_metadata,
    cygrpc.OperationType.receive_message,
    cygrpc.OperationType.receive_status_on_client,
)
_UNARY_STREAM_INITIAL_DUE = (
    cygrpc.OperationType.send_initial_metadata,
    cygrpc.OperationType.send_message,
    cygrpc.OperationType.send_close_from_client,
    cygrpc.OperationType.receive_initial_metadata,
    cygrpc.OperationType.receive_status_on_client,
)
_STREAM_UNARY_INITIAL_DUE = (
    cygrpc.OperationType.send_initial_metadata,
    cygrpc.OperationType.receive_initial_metadata,
    cygrpc.OperationType.receive_message,
    cygrpc.OperationType.receive_status_on_client,
)
_STREAM_STREAM_INITIAL_DUE = (
    cygrpc.OperationType.send_initial_metadata,
    cygrpc.OperationType.receive_initial_metadata,
    cygrpc.OperationType.receive_status_on_client,
)

_CHANNEL_SUBSCRIPTION_CALLBACK_ERROR_LOG_MESSAGE = (
    "Exception calling channel subscription callback!"
)

_OK_RENDEZVOUS_REPR_FORMAT = (
    '<{} of RPC that terminated with:\n\tstatus = {}\n\tdetails = "{}"\n>'
)

_NON_OK_RENDEZVOUS_REPR_FORMAT = (
    "<{} of RPC that terminated with:\n"
    "\tstatus = {}\n"
    '\tdetails = "{}"\n'
    '\tdebug_error_string = "{}"\n'
    ">"
)


def _deadline(timeout: Optional[float]) -> Optional[float]:
    return None if timeout is None else time.time() + timeout


def _unknown_code_details(
    unknown_cygrpc_code: Optional[grpc.StatusCode], details: Optional[str]
) -> str:
    return 'Server sent unknown code {} and details "{}"'.format(
        unknown_cygrpc_code, details
    )


class _RPCState(object):
    condition: threading.Condition
    due: Set[cygrpc.OperationType]
    initial_metadata: Optional[MetadataType]
    response: Any
    trailing_metadata: Optional[MetadataType]
    code: Optional[grpc.StatusCode]
    details: Optional[str]
    debug_error_string: Optional[str]
    cancelled: bool
    callbacks: List[NullaryCallbackType]
    fork_epoch: Optional[int]
    rpc_start_time: Optional[float]  # In relative seconds
    rpc_end_time: Optional[float]  # In relative seconds
    method: Optional[str]
    target: Optional[str]

    def __init__(
        self,
        due: Sequence[cygrpc.OperationType],
        initial_metadata: Optional[MetadataType],
        trailing_metadata: Optional[MetadataType],
        code: Optional[grpc.StatusCode],
        details: Optional[str],
    ):
        # `condition` guards all members of _RPCState. `notify_all` is called on
        # `condition` when the state of the RPC has changed.
        self.condition = threading.Condition()

        # The cygrpc.OperationType objects representing events due from the RPC's
        # completion queue. If an operation is in `due`, it is guaranteed that
        # `operate()` has been called on a corresponding operation. But the
        # converse is not true. That is, in the case of failed `operate()`
        # calls, there may briefly be events in `due` that do not correspond to
        # operations submitted to Core.
        self.due = set(due)
        self.initial_metadata = initial_metadata
        self.response = None
        self.trailing_metadata = trailing_metadata
        self.code = code
        self.details = details
        self.debug_error_string = None
        # The following three fields are used for observability.
        # Updates to those fields do not trigger self.condition.
        self.rpc_start_time = None
        self.rpc_end_time = None
        self.method = None
        self.target = None

        # The semantics of grpc.Future.cancel and grpc.Future.cancelled are
        # slightly wonky, so they have to be tracked separately from the rest of the
        # result of the RPC. This field tracks whether cancellation was requested
        # prior to termination of the RPC.
        self.cancelled = False
        self.callbacks = []
        self.fork_epoch = cygrpc.get_fork_epoch()

    def reset_postfork_child(self):
        self.condition = threading.Condition()


def _abort(state: _RPCState, code: grpc.StatusCode, details: str) -> None:
    if state.code is None:
        state.code = code
        state.details = details
        if state.initial_metadata is None:
            state.initial_metadata = ()
        state.trailing_metadata = ()


def _handle_event(
    event: cygrpc.BaseEvent,
    state: _RPCState,
    response_deserializer: Optional[DeserializingFunction],
) -> List[NullaryCallbackType]:
    callbacks = []
    for batch_operation in event.batch_operations:
        operation_type = batch_operation.type()
        state.due.remove(operation_type)
        if operation_type == cygrpc.OperationType.receive_initial_metadata:
            state.initial_metadata = batch_operation.initial_metadata()
        elif operation_type == cygrpc.OperationType.receive_message:
            serialized_response = batch_operation.message()
            if serialized_response is not None:
                response = _common.deserialize(
                    serialized_response, response_deserializer
                )
                if response is None:
                    details = "Exception deserializing response!"
   